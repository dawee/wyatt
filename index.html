<html>
  <head>
    <title>Wyatt</title>
    <link rel="stylesheet" type="text/css" href="./wyatt.css" />
    <link rel="stylesheet" type="text/css" href="./github.css" />
    <script type="text/javascript" src="./highlight.pack.js"></script>
  </head>
  <body>
    <div id="content">
      <div id="ban-wrapper">
        <div id="ban">
            <h1 id="wyatt">Wyatt</h1>
            <h2>brings <span class="light">mustache</span> into your <span class="light">Titanium</span> application</h2>
        </div>
        <a href="https://raw.github.com/dawicorti/wyatt/master/dist/wyatt-0.0.7.js"><div class="download">Download latest version (v0.0.7)</div></a>
      </div>
      <div id="doc-wrapper">

        <h2 id="introduction">Introduction</h2>
        <p>Since Titanium helps us writing complex mobile applications in Javascript, the pain has always been to describe views. Alloy had to solve this problem with the brand new XML approach plus its TSS style definition. For me as for many other Titanium developers, it was quite something and I was prepared to migrate all my former code to Alloy.</p>
        <p>The Alloy concept has been a bit frustrating for me. I'm an anti-precompiler. I think precompiling is a fail in a compilation process. I couldn't stand it in C, I don't like CoffeeScript, so I wasn't happy to see that Alloy came with its precompilation system behind a big MVC machine.</p>
        <p class="warning">Wyatt is not meant to replace Alloy.</p>
        <p>In fact, the development pattern is completely different : Alloy is a framwork, Wyatt is a simple template&query engine, that's it. The rest of the application : your MVC choice if you want MVC, your libs, your db manager ... I won't code your application, you're the boss here.</p>


        <h2 id="getting-started">Getting Started</h2>
        <h3>Write your <span class="light">index.yat</span> file</h3>
        <div class="example">
          <pre><code class="json">
{
  "el": "window",
  "options": {
    "fullscreen": true,
    "backgroundColor": "white"   
  },
  "tree": [
    {
      "el": "label",
      "options": {
        "text": "{{message}}"
      }
    }
  ]
}
          </code></pre>

          <h3>Then render it in your <span class="light">app.js</span> file</h3>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('index.yat', {message: 'Hello World !'})
// Finds and open the window
yat.first({el: "window"}).open();
          </code></pre>
        </div>
 
        <h2 id="yat">YAT Document</h2>
        
        <p>Wyatt read YAT Documents to render the element tree.</p>
        
        <h3 id="yat-syntax">Syntax</h3>
        
        <p>YAT syntax is basicaly JSON with some specials keys.</p>
        <ul>
          <li><span class="light">el :</span> the name of the element (e.g.: 'view', 'button', 'window' ...).</li>
          <li><span class="light">options :</span> an object to pass at the UI factory (Ti.UI.createWhatever)</li>
          <li><span class="light">tree :</span> the whole tree to append into the current UI</li>
        </ul>

        <h3 id="yat-mustache">Mustache basics</h3>
        
        <p>Mustache is the template processor used to generate the element tree from a given context.</p>
        <p>The logic-less system is fast to process and very adapted for mobile development.</p>
        <p>In a nutshell :</p>
        <ul>
          <li><span class="light">{{foobar}}</span> is replaced by the foobar value in the given context.</li>
          <li><span class="light">{{#titans}} {{name}} {{/titans}}</span> iters into the titans array to retrieve 'name' for each iteration.</li>
        </ul>
        
        <p>As the processor used is Handlebars (like was Wyatt Earp mustache),</p>
        <p>You can learn more here : <a href="http://handlebarsjs.com/">handlebarsjs.com</a></p>
        
        <h2 id="queries">Making Queries</h2>
        
        <p>When a document is rendered, the first thing you'll need to do is retrieve the elements to manipulate them.</p>
        <p>Queries are made for that.</p>
        <p>The methods listed here are callable from a YAT Document Object Model (generated by wyatt.render)</p>
        
        <h3 id="queries-any">yat.any(query)</h3>
        <p>Retrieve the list of elements in the document where the query match.</p>
        <p>The <span class="light">query</span> parameter is an object using like a filter.</p>
        <p>The keys in the filter can be "el" (to filter by element name) or anything defined in the YAT Document.</p>
        <p>Example :</p>
        <p><span class="light">query-example.yat</span> :</p>
        <div class="example">
          <pre><code class="json">
{
  "el": "view",

  "tree": [
    {
      {{#persons}}
      {
        "el": "label",
        "job": "{{job}}",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/persons}} 
    }
  ]
}
          </code></pre>
        <p><span class="light">app.js</span> :</p>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('query-example.yat', {
  persons: [
    {name: "John Smith", job: "developer"},
    {name: "Stewart McKay", job: "developer"},
    {name: "Bob White", job: "manager"},
  ]
});

// Finds all the developers and change their color
yat.any({el: "label", job: "developer"}).forEach(function (el) {
  el.attr('color': 'red');
});
          </code></pre>    

        <h3 id="queries-first">yat.first(query)</h3>
        <p>Same as above but return only the first element.</p>

        <h3 id="queries-subqueries">Sub Queries</h3>
        <p>Elements have their own YAT Document Object Model for their own tree.</p>
        <p>So they can be used as query proxies.</p>
        <p>Example :</p>


        <p><span class="light">subquery-example.yat</span> :</p>
        <div class="example">
          <pre><code class="json">
[
  {
    "el": "view",
    "food": "fruits",
    
    "tree": [
      {{#fruits}}
      {
        "el": "label",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/fruits}} 

    ]
  },
  {
    "el": "view",
    "food": "vegetables",
    
    "tree": [
      {{#vegetables}}
      {
        "el": "label",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/vegetables}} 

    ]
  }

]
          </code></pre>
        <p><span class="light">app.js</span> :</p>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('subquery-example.yat', {
  fruits: [
    {name: "Peach"},
    {name: "Apple"},
    {name: "Cherry"},
  ],
  vegetables: [
    {name: "Endive"},
    {name: "Letuce"}
  ]
});

// Finds all the vegetables and change their color
yat.first({id: "vegetables"}).any({el: "label"}).forEach(function (el) {
  el.attr('color': 'green');
});

      </div>
    </div>

      <div id="sidebar">
         <a class="toc_title" href="#wyatt">Wyatt <span class="version">(0.0.7)</span></a>
        <ul class="toc_section">
          <li>&raquo; <a href="http://github.com/dawicorti/wyatt">GitHub Repository</a></li>
        </ul>

        <a class="toc_title" href="#introduction">Introduction</a>
        <a class="toc_title" href="#getting-started">Getting Started</a>
        <a class="toc_title" href="#yat">YAT Document</a>
        <ul class="toc_section">
          <li><a href="#yat-syntax">Syntax</a></li>
          <li><a href="#yat-mustache">Mustache basics</a></li>
        </ul>
        <a class="toc_title" href="#queries">Making Queries</a>
        <ul class="toc_section">
          <li><a href="#queries-any">yat.any</a></li>
          <li><a href="#queries-first">yat.first</a></li>
          <li><a href="#queries-subqueries">Sub Queries</a></li>
        </ul>


      </div>

    <script>
       hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
