<html>
  <head>
    <title>Wyatt</title>
    <link rel="stylesheet" type="text/css" href="./wyatt.css" />
    <link rel="stylesheet" type="text/css" href="./github.css" />
    <script type="text/javascript" src="./highlight.pack.js"></script>
  </head>
  <body>
    <div id="content">
      <div id="ban-wrapper">
        <div id="ban">
            <h1 id="wyatt">Wyatt</h1>
            <h2>brings <span class="light">mustache</span> into your <span class="light">Titanium</span> application</h2>
        </div>
        <a href="https://raw.github.com/dawicorti/wyatt/master/dist/wyatt-0.0.8.js"><div class="download">Download latest version (v0.0.8)</div></a>
      </div>
      <div id="doc-wrapper">

        <h2 id="introduction">Introduction</h2>
        <p>Since Titanium helps us writing complex mobile applications in Javascript, the pain has always been to describe views. Alloy had to solve this problem with the brand new XML approach plus its TSS style definition. For me as for many other Titanium developers, it was quite something and I was prepared to migrate all my former code to Alloy.</p>
        <p>The Alloy concept has been a bit frustrating for me. I'm an anti-precompiler. I think precompiling is a fail in a compilation process. I couldn't stand it in C, I don't like CoffeeScript, so I wasn't happy to see that Alloy came with its precompilation system behind a big MVC machine.</p>
        <p class="warning">Wyatt is not meant to replace Alloy.</p>
        <p>In fact, the development pattern is completely different : Alloy is a framwork, Wyatt is a simple template&query engine, that's it. The rest of the application : your MVC choice if you want MVC, your libs, your db manager ... I won't code your application, you're the boss here.</p>


        <h2 id="getting-started">Getting Started</h2>
        <h3>Write your <span class="light">index.yat</span> file</h3>
        <div class="example">
          <pre><code class="json">
{
  "el": "window",
  "options": {
    "fullscreen": true,
    "backgroundColor": "white"   
  },
  "tree": [
    {
      "el": "label",
      "options": {
        "text": "{{message}}"
      }
    }
  ]
}
          </code></pre>

          <h3>Then render it in your <span class="light">app.js</span> file</h3>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('index.yat', {message: 'Hello World !'})
// Finds and open the window
yat.first({el: "window"}).open();
          </code></pre>
        </div>

        <h2 id="api">Wyatt API</h2>

        <h3 id="api-render">wyatt.render(path, context)</h3>
        <p>Returns a YAT Document from a template path and a given context.</p>

        <h3 id="api-yat">wyatt.yat(description)</h3>
        <p>Returns a YAT Document from a given description (Javascript Object).</p>

        <h3 id="api-el">wyatt.el(name)</h3>
        <p>Returns an Element constructor from its name (eg: 'view', 'button' ...).</p>

        <h3 id="api-register">wyatt.register(name, constructor)</h3>
        <p>Registers a constructor with the given name. The new name can be used next in a YAT Document.</p>

 
        <h2 id="yat">YAT Document</h2>
        
        <p>Wyatt read YAT Documents to render the element tree.</p>
        
        <h3 id="yat-syntax">Syntax</h3>
        
        <p>YAT syntax is basicaly JSON with some specials keys.</p>
        <ul>
          <li><span class="light">el :</span> the name of the element (e.g.: 'view', 'button', 'window' ...).</li>
          <li><span class="light">options :</span> an object to pass at the UI factory (Ti.UI.createWhatever)</li>
          <li><span class="light">tree :</span> the whole tree to append into the current UI</li>
        </ul>

        <h3 id="yat-mustache">Mustache basics</h3>
        
        <p>Mustache is the template processor used to generate the element tree from a given context.</p>
        <p>The logic-less system is fast to process and very adapted for mobile development.</p>
        <p>In a nutshell :</p>
        <ul>
          <li><span class="light">{{foobar}}</span> is replaced by the foobar value in the given context.</li>
          <li><span class="light">{{#titans}} {{name}} {{/titans}}</span> iters into the titans array to retrieve 'name' for each iteration.</li>
        </ul>
        
        <p>As the processor used is Handlebars (like was Wyatt Earp mustache),</p>
        <p>You can learn more here : <a href="http://handlebarsjs.com/">handlebarsjs.com</a></p>
        
        <h2 id="queries">Making Queries</h2>
        
        <p>When a document is rendered, the first thing you'll need to do is retrieve the elements to manipulate them.</p>
        <p>Queries are made for that.</p>
        <p>The methods listed here are callable from a YAT Document Object Model (generated by wyatt.render)</p>
        
        <h3 id="queries-any">yat.any(query)</h3>
        <p>Retrieve the list of elements in the document where the query match.</p>
        <p>The <span class="light">query</span> parameter is an object using like a filter.</p>
        <p>The keys in the filter can be "el" (to filter by element name) or anything defined in the YAT Document.</p>
        <p>Example :</p>
        <p><span class="light">query-example.yat</span> :</p>
        <p>Example :</p>
          <pre><code class="json">
{
  "el": "view",

  "tree": [
    {
      {{#persons}}
      {
        "el": "label",
        "job": "{{job}}",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/persons}} 
    }
  ]
}
          </code></pre>
        <p><span class="light">app.js</span> :</p>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('query-example.yat', {
  persons: [
    {name: "John Smith", job: "developer"},
    {name: "Stewart McKay", job: "developer"},
    {name: "Bob White", job: "manager"},
  ]
});

// Finds all the developers and change their color
yat.any({el: "label", job: "developer"}).forEach(function (el) {
  el.attr('color': 'red');
});
          </code></pre>    

        <h3 id="queries-first">yat.first(query)</h3>
        <p>Same as above but return only the first element.</p>

        <h3 id="queries-subqueries">Sub Queries</h3>
        <p>Elements have their own YAT Document Object Model for their own tree.</p>
        <p>So they can be used as query proxies.</p>
        <p>Example :</p>


        <p><span class="light">subquery-example.yat</span> :</p>
        <p>Example :</p>
          <pre><code class="json">
[
  {
    "el": "view",
    "food": "fruits",
    
    "tree": [
      {{#fruits}}
      {
        "el": "label",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/fruits}} 

    ]
  },
  {
    "el": "view",
    "food": "vegetables",
    
    "tree": [
      {{#vegetables}}
      {
        "el": "label",
        "options": {
          "text": "{{name}}"  
        }
      }
      {{/vegetables}} 

    ]
  }

]
          </code></pre>
        <p><span class="light">app.js</span> :</p>

          <pre><code class="javascript">
var wyatt = require('wyatt');

// Generates the UI
var yat = wyatt.render('subquery-example.yat', {
  fruits: [
    {name: "Peach"},
    {name: "Apple"},
    {name: "Cherry"},
  ],
  vegetables: [
    {name: "Endive"},
    {name: "Letuce"}
  ]
});

// Finds all the vegetables and change their color
yat.first({id: "vegetables"}).any({el: "label"}).forEach(function (el) {
  el.attr('color': 'green');
});
          </code></pre>


        <h2 id="element">Element</h2>
        
        <p>Elements (or view elements) are Titanium UI wrappers. This pattern is inspired by jQuery.</p>
        <p>You'll get an element instead of the direct UI, but Why ?</p>
        <p>An element will have a bunch of shorcuts and useful methods to helps you manipulating UI attributes and events.</p>
        <p>However, elements keep the UI intact and you can still retrieve it with <span class="light">el.ui</span> attribute</p>

        <h3 id="element-ui">.ui</h3>
        
        <p>ui attribute is a access to the original Titanium UI object (eg Ti.UI.View)</p>

        <h3 id="element-attr">.attr(key, value)</h3>

        <p>A single way to set parameters. Looks first for a setter (eg: 'color' -> ui.setColor). If the setter doesn't exist, use a simple patch</p>
        <p>Can be chained. Example :</p>

          <pre><code class="javascript">
yat
  .first({id: 'something'})
    .attr('color', 'white')
    .attr('width', '50px')
    .attr('opacity', 0.5)
          </code></pre>

        <h3 id="element-trigger">.trigger(event, data)</h3>

        <p>A proxy method to <span class="light">ui.fireEvent</span></p>

        <h3 id="element-on">.on(event, callback)</h3>

        <p>A proxy method to <span class="light">ui.addEventListener</span></p>

        <h3 id="element-off">.off(event, callback)</h3>

        <p>A proxy method to <span class="light">ui.removeEventListener</span></p>

        <h3 id="element-custom">Custom Element</h2>

        <p>Any element can be extended and used in the YAT document</p>
        <p>The process : retrieve the element by its name, extend it, override the create method.</p>
        <p>Example :</p>

          <pre><code class="javascript">
var wyatt = require('wyatt');

wyatt.register('redbutton', wyatt.el('button').extend({

  create: function (options) {
    options.backgroundColor = 'red';
    wyatt.el('button').prototype.create.apply(this, [options]);
  }

}));

//  Now 'redbutton' can be used in a YAT Document.

          </code></pre>     

      </div>
    </div>

      <div id="sidebar">
         <a class="toc_title" href="#wyatt">Wyatt <span class="version">(0.0.8)</span></a>
        <ul class="toc_section">
          <li>&raquo; <a href="http://github.com/dawicorti/wyatt">GitHub Repository</a></li>
        </ul>

        <a class="toc_title" href="#introduction">Introduction</a>

        <a class="toc_title" href="#getting-started">Getting Started</a>

        <a class="toc_title" href="#api">Wyatt API</a>
        <ul class="toc_section">
          <li><a href="#api-render">wyatt.render(path, context)</a></li>
          <li><a href="#api-yat">wyatt.yat(description)</a></li>
          <li><a href="#api-el">wyatt.el(name)</a></li>

          <li><a href="#api-register">wyatt.register(name, constructor)</a></li>

        </ul>

        <a class="toc_title" href="#yat">YAT Document</a>
        <ul class="toc_section">
          <li><a href="#yat-syntax">Syntax</a></li>
          <li><a href="#yat-mustache">Mustache basics</a></li>
        </ul>
        <a class="toc_title" href="#queries">Making Queries</a>
        <ul class="toc_section">
          <li><a href="#queries-any">yat.any</a></li>
          <li><a href="#queries-first">yat.first</a></li>
          <li><a href="#queries-subqueries">Sub Queries</a></li>
        </ul>

        <a class="toc_title" href="#element">Element</a>
        <ul class="toc_section">
          <li><a href="#element-ui">  .ui</a></li>
          <li><a href="#element-attr">  .attr(key, value)</a></li>

          <li><a href="#element-trigger">  .trigger(event, data)</a></li>
          <li><a href="#element-on">  .on(event, callback)</a></li>
          <li><a href="#element-off">  .off(event, callback)</a></li>
          <li><a href="#element-custom">Custom Element</a></li>
        </ul>


      </div>

    <script>
       hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
